FUNCTION lpm_add_sub (cin, dataa[LPM_WIDTH-1..0], datab[LPM_WIDTH-1..0], add_sub, clock, aclr, clkn)
   WITH (LPM_WIDTH, LPM_REPRESENTATION, LPM_DIRECTION, ONE_INPUT_IS_CONSTANT, LPM_PIPELINE, MAXIMIZE_SPEED)
   RETURNS (result[LPM_WIDTH-1..0], cout, overflow);
FUNCTION lpm_dff (data[LPM_WIDTH-1..0], clock, enable, shiftin, shiften, sclr, sset, sconst, aclr, aset, aconst)
   WITH (LPM_WIDTH, LPM_AVALUE, LPM_SVALUE)
   RETURNS (q[LPM_WIDTH-1..0], shiftout);
FUNCTION lpm_abs (data[LPM_WIDTH-1..0])
   WITH (LPM_WIDTH, ADDERTYPE)
   RETURNS (result[LPM_WIDTH-1..0], overflow);
FUNCTION lpm_counter (data[LPM_WIDTH-1..0], clock, clk_en, cnt_en, updown, cin, aclr, aset, aconst, aload, sclr, sset, sconst, sload)
   WITH (LPM_WIDTH, LPM_DIRECTION, LPM_MODULUS, LPM_AVALUE, LPM_SVALUE, CARRY_CNT_EN, LABWIDE_SCLR)
   RETURNS (q[LPM_WIDTH-1..0], cout, eq[15..0]);
FUNCTION lpm_shiftreg (data[LPM_WIDTH-1..0], clock, enable, shiftin, load, sclr, sset, aclr, aset)
   WITH (LPM_WIDTH, LPM_DIRECTION, LPM_AVALUE, LPM_SVALUE)
   RETURNS (q[LPM_WIDTH-1..0], shiftout);
FUNCTION bit_nco(clk_sys,nco_f[31..0])
   RETURNS (result[31..0],bs);
FUNCTION mul16x16(clock,dataa[15..0],datab[15..0])
   RETURNS (result[31..0]);
FUNCTION 3add32(clock,data0x[31..0],data1x[31..0],data2x[31..0])
   RETURNS (result[31..0]);


SUBDESIGN code_type_rb
(
	clk_sys			: INPUT;
	pcm_d				: input;
	rb					:input;
	plus_bit			:input;
	pcm_type[3..0]	: input;
	bs					: OUTPUT;
	bd					: OUTPUT;
)
VARIABLE
	nrz_to_rnrz		:lpm_shiftreg WITH (LPM_WIDTH=15);
	buf_bs_c			:dffe;
	dvl_bs			: dffe;
	ms_to_l			:dffe;
	l_m_s				:dffe;
	l_m_s_a			:node;
	bi_fi				:dffe;
	nrz				:node;
	nrz_l				:node;
	rnrz				:node;
	bs_a				:node;
	bs_b				:node;
	bs_c				:node;
	bd_buf			:dffe;
	ena_data			:node;

BEGIN
%----code type -----------%
	dvl_bs=!dvl_bs;
	dvl_bs.ena=plus_bit;
	dvl_bs.clk=clk_sys;
	bs_a=rb;
	bs_b=dvl_bs;
	
	buf_bs_c=bs_c;
	buf_bs_c.clk=clk_sys;
	
	bd_buf=nrz;
	bd_buf.ena=bs_c and !buf_bs_c;
	bd_buf.clk=clk_sys;
	
	bd=bd_buf;
	bs=bs_c;
	
	if ((!pcm_type[3]) and pcm_type[2])==1 then
				bs_c=!bs_b;
				l_m_s_a=bi_fi;
				ena_data=!bs_b and plus_bit;
		else    bs_c=!bs_a;
				l_m_s_a=nrz_l;
				ena_data=plus_bit;
	end if;

	rnrz=pcm_d xor (nrz_to_rnrz.q[13] xor nrz_to_rnrz.q[14]);
	nrz_to_rnrz.enable=plus_bit;
	nrz_to_rnrz.clock=clk_sys;
	nrz_to_rnrz.shiftin=pcm_d;

	if pcm_type[3]==1 then nrz_l=rnrz;
		else nrz_l=pcm_d;
	end if;

	l_m_s.clk=clk_sys;
	l_m_s.ena=ena_data;
	l_m_s=l_m_s_a;
	
	ms_to_l.clk=clk_sys;
	ms_to_l.ena=ena_data;
	ms_to_l.d=(!pcm_type[3] and pcm_type[0]) xor (l_m_s_a xor l_m_s);
	
	if (!pcm_type[3] and pcm_type[1])==1 then nrz=ms_to_l;
		else nrz=l_m_s;
	end if;

	
	bi_fi=pcm_d;
	bi_fi.clk=clk_sys;
	bi_fi.ena=ena_data;
	
END;
